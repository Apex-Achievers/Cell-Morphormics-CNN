import tensorflow as tf
from tensorflow.keras.applications import ResNet50
from tensorflow.keras import layers, models

def create_transfer_model(input_shape, num_classes, embedding_dim=128):
    # Load the ResNet50 model, pre-trained on ImageNet
    # include_top=False removes the final classification layer
    # weights='imagenet' loads the pre-trained weights
    # input_shape must have 3 channels for ImageNet weights. We will adapt our 4-channel input.
    
    # Create an input layer that accepts our 4-channel images
    inputs = layers.Input(shape=input_shape)
    
    # Add a Conv2D layer to project the 4 channels down to 3 channels
    # This layer will be trainable and learn the best way to combine the 4 channels
    x = layers.Conv2D(3, (1, 1), padding='same', name='channel_projection')(inputs)
    
    # Load the base model
    base_model = ResNet50(include_top=False, weights='imagenet', input_tensor=x)
    
    # Freeze the weights of the base model so they are not updated during training
    base_model.trainable = False
    
    # Add new classification layers on top
    # Use the output of the base model
    x = base_model.output
    # Add a global average pooling layer to reduce dimensions
    x = layers.GlobalAveragePooling2D()(x)
    # Add the dense embedding layer - THIS IS OUR MORPHOLOGICAL PROFILE
    x = layers.Dense(embedding_dim, activation='relu', name='embedding_layer')(x)
    # Add a dropout layer to prevent overfitting
    x = layers.Dropout(0.5)(x)
    # Add the final classification layer
    outputs = layers.Dense(num_classes, name='classification_head')(x)
    
    # Create the final model
    model = models.Model(inputs, outputs, name="TransferLearningModel")
    
    return model

# Usage:
# input_shape = (224, 224, 4)
# num_classes = len(metadata_df['label_id'].unique())
# transfer_model = create_transfer_model(input_shape, num_classes)
# transfer_model.summary()
